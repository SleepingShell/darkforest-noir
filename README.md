Noir implementation of the circuits involved in the Dark Forest game (https://zkga.me).

As a demonstration of the Noir language, this repository aims to adapt the zero knowledge verification in the smart contracts to ones generated by [Noir](https://aztec.network/noir).

# Aspects of the game involving ZKPs
The goal of the dark forest project is to create a game in which there is a trustless state of the system, aka the objects and their owners inside the finite galaxy, where participants only have a partial view into the state of the game.

This is mostly achieved through its *fog of war*. Players must mine, similar to Proof of Work currencies, the locations of planets by sequencing through points in space. Similar to PoW, only certain points in space will contain planets (based on their rarity), and this calculation depends on the hash commitment of the point in space, and its corresponding Perlin value. Unlike PoW, the point that generated this hash (aka **Location ID**) is not revealed publicly (until the corresponding function to do so is called). 

Using zero knowledge proofs, we can prove properties about a point in space, without revealing the actual ``(x,y)`` coordinates. Whenever a player initializes or moves to a planet, a proof is provided attesting to the valid values of the hash commitment and perlin value, which *are* provided to the publicly known state.

The power of this is that not only is a fog of war possible in a completely security-equal computing enviornment, but also that fog of war can be procedurally generated without having to store the state anywhere.


## Perlin Noise
[Perlin Noise](https://en.wikipedia.org/wiki/Perlin_noise) is a common method in gaming for procedural generation. It is a function that creates smooth scaling of its output while still containing random generation. Points that are closer together will have closer perlin values. 

The high level overview of Perlin scaling is that it will segment the defined space into a grid of set lengths. Each vertex of the grid will have a randomly directed gradient vector in order to add randomness to the output. Depending on how close a point is to the 4 gradients of the square it is in will determine its influence on the output value.